import os
import re

from . import mavtemplate

t = mavtemplate.MAVTemplate()

def camelize(name):
    tokens = name.split('_')
    ctokens = map(lambda tok: tok[0]+(tok[1:].lower()), tokens)
    return ''.join(ctokens)

def convert_type(type, array_length):
    table = {
        'float'     : 'float32',
        'double'    : 'float64',
        'char'      : 'bool',
        'int8_t'    : 'int8',
        'uint8_t'   : 'uint8',
        'int16_t'   : 'int16',
        'uint16_t'  : 'uint16',
        'int32_t'   : 'int32',
        'uint32_t'  : 'uint32',
        'int64_t'   : 'int64',
        'uint64_t'  : 'uint64'
    }
    ret = table[type]
    if array_length != 0:
        ret += '[%d]' % (array_length)
    return ret

def generate_enums(basedir, enums):
    for enum in enums:
        cname = camelize(enum.name)
        outfile = os.path.join(basedir, cname+'.msg')
        outf = open(outfile, "w")
        for entry in enum.entry:
            if entry.description != '':
                outf.write("# %s\n" % (entry.description))
            outf.write("uint8 %s=%d\n" % (entry.name, entry.value))
        outf.close()

def generate_src(srcdir, tms, gets, sets, replys, replyMap):
    # tmtc.h #######################################################
    headerpath = os.path.join(srcdir, 'tmtc.h')
    if os.path.exists(headerpath):
        os.remove(headerpath)
    srcf = open(headerpath, "w")
    t.write(srcf, """
#ifndef _TMTC_H 
#define _TMTC_H

// Autogenerated by tmtc-lib-mavlink.
// DO NOT alter this file by your hand!
// Sungkook Kim was here. 2018-06-21

#include <vector>
#include <string>
#include <serial/serial.h>
#include <mavlink_types.h>
#include <nearthlab/mavlink.h>
#include <nearthlab/nearthlab.h>
#include <rosgraph_msgs/Log.h>

""")
    ## include ##
    for x in tms:
        cname = camelize(x.name)
        t.write(srcf, """
#include <tmtc_msg/${NAME}.h>
""", {'NAME': cname})
    for x in sets:
        cname = camelize(x.name)
        t.write(srcf, """
#include <tmtc_msg/${NAME}.h>
""", {'NAME': cname})
    for x in gets:
        cname = camelize(x.name)
        t.write(srcf, """
#include <tmtc_msg/${NAME}.h>
""", {'NAME': cname})
    for x in replys:
        cname = camelize(x.name)
        t.write(srcf, """
#include <tmtc_msg/${NAME}.h>
""", {'NAME': cname})
    t.write(srcf, """

using std::string;
using std::vector;
using serial::Serial;
using serial::Timeout;
using ros::NodeHandle;
using ros::Subscriber;
using ros::Publisher;
using ros::ServiceClient;

namespace nlab
{
namespace mc
{
class Tmtc
{
public:
  Tmtc(string dev, int32_t baud);
  ~Tmtc();

  bool Open();
  bool Close();
  bool IsOpen();
  void Send(vector<uint8_t> bytes);
  void Send(const string& s);
  string ReadStringSerial();
  void ReadTc();
  void ParseTc(uint8_t* buf, uint32_t size);
  void Flush();

private:
  const uint8_t SYS_ID = 0;
  const uint8_t COMP_ID = MAV_COMP_ID_FMCU;
  vector<uint8_t> bufTx_;

  Serial* serial_ = nullptr;

  bool OpenSerial();
  bool IsOpenSerial();
  void SendSerial(vector<uint8_t> bytes);
  void SendMavlink(mavlink_message_t* msg);

  mavlink_status_t mavRxStatus_;
  mavlink_message_t msgRx_;
  mavlink_message_t msgTx_;

  NodeHandle nh_;
  Subscriber subRoslog_;

  void SendText(const string& str);
  void SendText(const string& str, MAV_SEVERITY sverity);
  void SendAck(uint8_t cmdId, MAV_RESULT result);
  void SubRoslog(const rosgraph_msgs::Log& log);

""")

    for x in tms:
        cname = camelize(x.name)
        t.write(srcf, """
  Subscriber sub${NAME}_;
  void cb${NAME}(const tmtc_msg::${NAME}::ConstPtr& msg);
""", {'NAME': cname})
    for x in sets:
        cname = camelize(x.name)
        t.write(srcf, """
  ServiceClient client${NAME}_;
  void call${NAME}();
""", {'NAME': cname})
    for x in gets:
        cname = camelize(x.name)
        t.write(srcf, """
  ServiceClient client${NAME}_;
  void call${NAME}();
""", {'NAME': cname})
    t.write(srcf, """
};
}
}
#endif
""")
    srcf.close()

    # tmtc.cpp #######################################################
    srcpath = os.path.join(srcdir, 'tmtc.cpp')
    if os.path.exists(srcpath):
        os.remove(srcpath)
    srcf = open(srcpath, "w")
    t.write(srcf, """
// Autogenerated by tmtc-lib-mavlink.
// DO NOT alter this file by your hand!
// Sungkook Kim was here. 2018-06-21

#include <cstring>
#include <ros/ros.h>
#include <rosgraph_msgs/Log.h>

#include "tmtc.h"

namespace nlab
{
namespace mc
{
""")
    ## Callbacks for TM ##
    for x in tms:
        cname = camelize(x.name)
        t.write(srcf, """

void Tmtc::cb${NAME}(const tmtc_msg::${NAME}::ConstPtr& msg) {
  mavlink_${LNAME}_t mavmsg = {};
""", {'NAME': cname, 'LNAME': x.name_lower})
        for f in x.fields:
            if f.array_length == 0:
                t.write(srcf, """
  mavmsg.${FNAME} = msg->${FNAME};
""", {'FNAME': f.name})
            else:
                t.write(srcf, """
  memcpy(&(mavmsg.${FNAME}), &(msg->${FNAME}), ${LEN});
""", {'FNAME': f.name, 'LEN': f.wire_length})
        t.write(srcf, """
  mavlink_msg_${LNAME}_encode(SYS_ID, COMP_ID, &msgTx_, &mavmsg);
  SendMavlink(&msgTx_);
  printf("${LNAME}\\n");
}
""", {'LNAME': x.name_lower})
    ## Service calls for SET ##
    for x in sets:
        cname = camelize(x.name)
        t.write(srcf, """

void Tmtc::call${NAME}() {
  tmtc_msg::${NAME} srv;
""", {'NAME': cname})
        for f in x.fields:
            if f.array_length == 0:
                t.write(srcf, """
  srv.request.${FNAME} = mavlink_msg_${LNAME}_get_${FNAME}(&msgRx_);
""", {'LNAME': x.name_lower, 'FNAME': f.name})
            else:
                t.write(srcf, """
  mavlink_msg_${LNAME}_get_${FNAME}(&msgRx_, (${TYPE}*)&(srv.request.${FNAME}));
""", {'LNAME': x.name_lower, 'FNAME': f.name, 'LEN': f.wire_length, 'TYPE': f.type})
        t.write(srcf, """
  if (client${NAME}_.call(srv)) {
    SendAck(msgRx_.msgid, (MAV_RESULT)srv.response.ack);
  }
  else {
    ROS_ERROR("Failed to call service ${LNAME}");
    return;
  }
  printf("${LNAME}\\n");
}
""", {'NAME': cname, 'LNAME': x.name_lower})
    ## Service calls for GET ##
    for x in gets:
        cname = camelize(x.name)
        t.write(srcf, """

void Tmtc::call${NAME}() {
  tmtc_msg::${NAME} srv;
""", {'NAME': cname})
        for f in x.fields:
            if f.array_length == 0:
                t.write(srcf, """
  srv.request.${FNAME} = mavlink_msg_${LNAME}_get_${FNAME}(&msgRx_);
""", {'LNAME': x.name_lower, 'FNAME': f.name})
            else:
                t.write(srcf, """
  mavlink_msg_${LNAME}_get_${FNAME}(&msgRx_, (${TYPE}*)&(srv.request.${FNAME}));
""", {'LNAME': x.name_lower, 'FNAME': f.name, 'LEN': f.wire_length, 'TYPE': f.type})
        t.write(srcf, """
  if (client${NAME}_.call(srv)) {
    mavlink_${RLNAME}_t mavmsg = {}; 
""", {'NAME': cname, 'RLNAME': x.name_lower.replace('get', 'reply')})
        for f in replyMap[x.name.replace('GET', 'REPLY')].fields:
            if f.array_length == 0:
                t.write(srcf, """
    mavmsg.${FNAME} = srv.response.reply.${FNAME};
""", {'FNAME': f.name})
            else:
                t.write(srcf, """
    memcpy(&(mavmsg.${FNAME}), &(srv.response.reply.${FNAME}), ${LEN});
""", {'FNAME': f.name, 'LEN': f.wire_length})
        t.write(srcf, """
    mavlink_msg_${RLNAME}_encode(SYS_ID, COMP_ID, &msgTx_, &mavmsg);
    SendMavlink(&msgTx_);
""", {'NAME': cname, 'RLNAME': x.name_lower.replace('get', 'reply')})
        t.write(srcf, """
  }
  else {
    ROS_ERROR("Failed to call service ${LNAME}");
    return;
  }
  printf("${LNAME}\\n");
}
""", {'NAME': cname, 'LNAME': x.name_lower})
    ## Constructor ##
    t.write(srcf, """

Tmtc::Tmtc(string dev, int32_t baud)
{
  serial_ = new Serial(dev, baud);
  ROS_INFO("TMTC-Serial on");
  subRoslog_ = nh_.subscribe("/rosout", 100, &Tmtc::SubRoslog, this);
""")
    for x in tms:
        cname = camelize(x.name)
        t.write(srcf, """
  sub${NAME}_ = nh_.subscribe("${NAME}", 100, &Tmtc::cb${NAME}, this);
""", {'NAME': cname})
    for x in sets:
        cname = camelize(x.name)
        t.write(srcf, """
  client${NAME}_ = nh_.serviceClient<tmtc_msg::${NAME}>("/${NAME}");
""", {'NAME': cname})
    for x in gets:
        cname = camelize(x.name)
        t.write(srcf, """
  client${NAME}_ = nh_.serviceClient<tmtc_msg::${NAME}>("/${NAME}");
""", {'NAME': cname})
    t.write(srcf, """
}

Tmtc::~Tmtc()
{
  if (serial_ != nullptr)
    delete (serial_);
}

bool Tmtc::Open()
{
  return OpenSerial();
}

bool Tmtc::OpenSerial()
{
  if (serial_->isOpen())
    return true;
  try
  {
    serial_->open();
    return true;
  }
  catch (const serial::PortNotOpenedException&)
  {
    ROS_ERROR("Unable to open port");
    return false;
  }
  catch (const std::exception& e)
  {
    ROS_ERROR("Serial exception %s", e.what());
  }
}

bool Tmtc::Close()
{
  if (serial_ != nullptr)
    serial_->close();
}

bool Tmtc::IsOpen()
{
  return IsOpenSerial();
}

bool Tmtc::IsOpenSerial()
{
  if (serial_ == nullptr)
    return false;
  return serial_->isOpen();
}

void Tmtc::Send(vector<uint8_t> bytes)
{
  if (serial_ != nullptr)
    SendSerial(bytes);
  Flush();
}

void Tmtc::SendSerial(vector<uint8_t> bytes)
{
  for (auto& b : bytes)
    bufTx_.push_back(b);
}

void Tmtc::Send(const string& s)
{
  // Send strings as bytes for consistency.
  vector<uint8_t> vec(s.begin(), s.end());
  Send(vec);
}

string Tmtc::ReadStringSerial()
{
  if (serial_ == nullptr)
    return "";
  auto len = serial_->available();
  return serial_->read(len);
}

void Tmtc::Flush()
{
  if (serial_ != nullptr)
  {
    serial_->write(bufTx_);
  }
  bufTx_.clear();
}

void Tmtc::SendMavlink(mavlink_message_t* pMsg)
{
  uint8_t buf[sizeof(mavlink_message_t)];
  uint32_t len = mavlink_msg_to_send_buffer(buf, pMsg);
  vector<uint8_t> vec(buf, buf + len);
  Send(vec);
}

void Tmtc::SendText(const string& str)
{
  SendText(str, MAV_SEVERITY_DEBUG);
}

void Tmtc::SendText(const string& str, MAV_SEVERITY sverity)
{
  int nBytes = static_cast<int>(str.length());
  auto nCopy = std::min(nBytes, MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN);
  char* buf[MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN];
  memset(buf, 0, MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN);
  memcpy(buf, str.c_str(), nCopy);
  mavlink_msg_statustext_pack(SYS_ID, COMP_ID, &msgTx_, sverity, reinterpret_cast<const char*>(buf));
  SendMavlink(&msgTx_);
}
void Tmtc::SendAck(uint8_t cmdId, MAV_RESULT result)
{
  mavlink_msg_nl_ack_pack(SYS_ID, COMP_ID, &msgTx_, cmdId, result, 0);
  SendMavlink(&msgTx_);
}

void Tmtc::SubRoslog(const rosgraph_msgs::Log& log)
{
  string name = log.name;

  if (log.name.find("mc_guidance") != string::npos)
  {
    name = "GD";
  }
  else if (log.name.find("dl_mp") != string::npos)
  {
    name = "MP";
  }
  else if (log.name.find("motor_control_publisher") != string::npos)
  {
    name = "FC";
  }
  else
  {
    return;
  }

  auto msg = boost::format("[%s] %s") % name % log.msg;
  SendText(str(msg));
}

void Tmtc::ReadTc()
{
  string result = ReadStringSerial();  // TODO: Make two objects!
  char* buf = (char*)result.c_str();
  size_t len = result.length();
  ParseTc((uint8_t*)buf, len);
}

void Tmtc::ParseTc(uint8_t* buf, uint32_t size)
{
  for (auto i = 0; i < size; ++i) {
    if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msgRx_, &mavRxStatus_)) {
      switch (msgRx_.msgid) {
""")
    ## Mav listeners ##
    for x in sets:
        cname = camelize(x.name)
        t.write(srcf, """
      case MAVLINK_MSG_ID_${UNAME}:
        Tmtc::call${NAME}();
        break;
""", {'NAME': cname, 'UNAME': x.name})
    for x in gets:
        cname = camelize(x.name)
        t.write(srcf, """
      case MAVLINK_MSG_ID_${UNAME}:
        Tmtc::call${NAME}();
        break;
""", {'NAME': cname, 'UNAME': x.name})
    t.write(srcf, """
      default:
        ROS_ERROR("Unsupported TC %d", msgRx_.msgid);
      }
    }
  }
}

}
}
""")

def generate(basedir, xml):
    '''create ros msgs & srvs for tm|get|set|reply'''
    msgdir = os.path.join(basedir, 'msg')
    srvdir = os.path.join(basedir, 'srv')

    msgs = []
    enums = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)

    generate_enums(msgdir, enums)

    tms = []
    gets = []
    sets = []
    replys = []
    replyMap = {}
    # msg & srv generation
    for m in msgs:
        if m.rosmethod == None:
            continue
        cname = camelize(m.name)
        if m.rosmethod == 'TM':
            # msg generation
            outfile = os.path.join(msgdir, cname+'.msg')
            outf = open(outfile, "w")
            for f in m.fields:
                if f.description != '':
                    outf.write("# %s\n" % (f.description))
                ctype = convert_type(f.type, f.array_length)
                outf.write("%s %s\n" % (ctype, f.name))
            outf.close()
            tms.append(m)
        elif m.rosmethod == 'GET':
            # srv generation
            outfile = os.path.join(srvdir, cname+'.srv')
            outf = open(outfile, "w")
            for f in m.fields:
                if f.description != '':
                    outf.write("# %s\n" % (f.description))
                ctype = convert_type(f.type, f.array_length)
                outf.write("%s %s\n" % (ctype, f.name))
            outf.write("---\n")
            outf.write("%s reply\n" % (camelize(m.name.replace('GET', 'REPLY'))))
            outf.close()
            gets.append(m)
        elif m.rosmethod == 'SET':
            # srv generation
            outfile = os.path.join(srvdir, cname+'.srv')
            outf = open(outfile, "w")
            for f in m.fields:
                if f.description != '':
                    outf.write("# %s\n" % (f.description))
                ctype = convert_type(f.type, f.array_length)
                outf.write("%s %s\n" % (ctype, f.name))
            outf.write("---\n")
            outf.write("bool ack\n")
            outf.close()
            sets.append(m)
        elif m.rosmethod == 'REPLY':
            # msg generation
            outfile = os.path.join(msgdir, cname+'.msg')
            outf = open(outfile, "w")
            for f in m.fields:
                if f.description != '':
                    outf.write("# %s\n" % (f.description))
                ctype = convert_type(f.type, f.array_length)
                outf.write("%s %s\n" % (ctype, f.name))
            outf.close()
            replys.append(m)
            replyMap[m.name] = m
    
    # src generation
    generate_src(os.path.join(basedir, 'src'), tms, gets, sets, replys, replyMap)
